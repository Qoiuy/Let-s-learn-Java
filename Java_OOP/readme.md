# Java OOP (面对对象程序设计)
### 封装 
#### 概念:指隐藏对象的属性和实现细节。仅对外提供公共访问方式。
#### 好处:将变化隔离；便于使用；提高重用性；安全性。 
#### 封装原则:将不需要对外提供的内容都隐藏起来，把属性都隐藏起来，提供共有方法对其访问。
------
### 单例模式
#### 解决的问题:保证一个类在内存中的唯一性
#### 举例:多个项目使用同一个配置文件，建议将该文件封装成一个类，这样就方便操作其中的数据了，又要保证多个程序读取到的文件是同一个配置文件，就需要确定该配置对象在内存中使唯一的。
#### 如何能保证对象的唯一性: 1不让其他程序创建该类。 2在本类中创建一个本类对象 3对外提供方法，让其他对象获取这个对象。
#### 代码实现 : 1 构造函数私有化 2内部产生该类的实例化 并将其封装成 private static 3静态方法返回该类的实例
#### 4种实现单例的例子:
`饿汉式 sington.Hungry 线程安全,特定情况下耗费内存`
![实现代码](https://github.com/Qoiuy/Let-s-learn-Java/blob/master/Java_OOP/src/main/java/sington/Hungry.java)
</br>`饱汉式（简单） sington.SimpleFull 线程不安全,特定情况下节约内存`
![实现代码](https://github.com/Qoiuy/Let-s-learn-Java/blob/master/Java_OOP/src/main/java/sington/SimpleFull.java)
</br>`饱汉式（sync）sington.SyncFull 线程安全,节约内存,但是同步方法调用频繁时 效率低`
![实现代码](https://github.com/Qoiuy/Let-s-learn-Java/blob/master/Java_OOP/src/main/java/sington/SyncFull.java)
</br>`饱汉式（best）sington.BestFull 线程安全,节约内存,多线程操作原子性`
![实现代码](https://github.com/Qoiuy/Let-s-learn-Java/blob/master/Java_OOP/src/main/java/sington/BestFull.java)
#### Runtime: 典型的单例模式 
------

### 继承
#### 好处:提高了代码的复用性。 让类和类之间产生了关系。
#### 子类中所有的构造函数都会默认访问父类中空参构造函数。
parent static
****************
child static
parent 构造函数
parent a =10
child 构造函数
child a = 20
------

### final
#### 修饰类:不可被继承
#### 修饰方法 :不可被覆盖
#### 修饰变量:不可被赋值
------

### 抽象类
#### 抽象方法只能定义在抽象类中，
#### 抽象类里面只定义方法声明，不定义方法实现
#### 抽象类不可被实例化
#### 子类继承并覆盖所有方法后才能被实例化。
#### 抽象类单继承
#### 细节1，抽象类中可以有构造方法，用于给子类对象进行初始化
#### 细节2.抽象类中可以定义非抽象方法
#### 细节3.abstract 不能和 final private static共存。
#### 细节4.抽象类中可以不定义抽象方法。
------

### 接口和抽象类区别
#### 接口需要被实现，可以多继承 		抽象类只能被继承，只能单继承
#### 接口里面都是抽象方法，需要子类来实现  抽象类中可以定义非抽象方法，子类直接继承使用  
#### 接口是like a 关系 				抽象类是is a关系
#### 接口成员修饰符固定public 		抽象类修饰符自定义
------

### 多态
#### 体现:父类引用或者接口的引用指向自己的子类对象
#### 好处:提高了程序的扩展性
#### 弊端:当父类引用指向子类对象时，只能访问子类中具备的方法，不能访问子类中特有的方法，
#### 多态的前提：必须要有关系 有覆盖操作。
------

### 匿名内部类
#### 没有名字的内部类。其实就是一个匿名子类对象。
#### 前提:内部类必须继承一个类或者实现接口。
#### 格式:new 父类名&接口名(){定义子类成员或者覆盖父类方法}
#### 使用场景:当函数的参数是接口类型的引用时，如果该接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递
------

### 异常
#### 异常处理原则:功能抛出几个异常，功能调用如果进行try处理，需要与之对应的catch处理代码块，这样的处理具有针对性，抛几个就处理几个。
#### 特殊情况:try对应多个catch时，如果有父类的catch语句块，一定要放在下面
------

### throw 和 throws关键字的区别
#### throw用于抛出异常对象，后面跟着的是异常对象；用在函数内
#### throws用于抛异常类，后面跟的异常类名，可以跟多个，用逗号隔开;修饰函数







